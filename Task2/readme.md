# 任务2实现情况（针对Python LogRecord)

## 主要目录文件与内容

|      文件      |                             内容                             |
| :------------: | :----------------------------------------------------------: |
|  LogContent.h  |             定义了接口中的`Content`、`Log`两个类             |
|  logProcess.h  | 定义了`FormatSubString`类以及相关常量（如`ASCTIME`字段的固定长度等）<br />声明了接口中的`Process`函数以及封装的其它函数 |
| logProcess.cpp | **实现了主要的函数**，包括接口中的`Process`函数<br />处理单条Log的`processSingle`函数<br />对格式字符串预处理的`preProcess`函数 |
|    main.cpp    |                    内含一些简单的测试样例                    |

## 实现前对格式字符串的讨论

#### 引言

需要被实现的接口为`void Process(std::string format, vector<std::string>& input, vector<Log>& output);`

`format`作为格式字符串，应当与Python `logging`模块中，创建`Formatter`所提供的格式字符串`f`**紧密相关**，否则该接口将不易用。

这里就会存在问题：向`Process`函数传入格式字符串`format`究竟是否需要与用户在`logging`模块中为`Formatter`所提供的格式字符串`f`**完全一致**？如果不完全一致，我们要做多少**增量定义**？

#### 增量定义的Trade-off

对格式字符串增量定义的多少将直接关系到**用户的易用性**、**日志格式的灵活性**、**日志解析速度**与**解析函数实现难度**。可能存在如下图所示的定性关系：

![image-20230914111353809](https://github.com/4lex49/ilogtail/blob/fcc04d346b587c46813c7717324714700d2bef61/Task2/imgs/image-20230914111353809.png)

不妨举几个极端的例子：

* 若格式字符串将每个占位符所对应的日志内容的长度严格定义（即增量定义量非常大），如严格定义`%message`字段长度为固定的50字符，则
  * ilogtail的相关接口对于用户来说将难以使用，且日志将变得非常死板
    * python中定义的`Formatter`的格式字符串很少包含“字段长度”这一信息，因此需要用户手动修改才能用于ilogtail接口
    * 日志字段长度受到限制，日志中`%message%`字段对应的串长度长或短于50字符都将导致解析失败
  * 但日志解析速度将大大提高，且解析函数的实现难度将非常之低
    * 因为只需直接从日志串中截取响应长度即可，解析速度很快，且实现难度低
* 若格式字符串与Python的要求完全相同，即完全不进行增量定义，则
  * ilogtail的相关接口对于用户来说将非常简单，且日志格式也非常灵活
    * 用户只需从python的日志实现代码中拷贝格式字符串到ilogtail接口即可，使用方便
    * 日志格式灵活，长度限制很小
  * 但日志解析速度将受到限制，解析函数的复杂性也将大大提高
    * 因为**Formatter**所规定的是用于**输出**的格式字符串，若将其作为日志解析的定义则将很可能导致解析时出现歧义
    * 为了解决歧义，**至少必须**引入**回溯**机制，这将严重限制日志的解析速度，提高解析函数的实现难度

#### 当前实现所采用的思路

按照ilogtail官方对我实现方案的反馈，似乎官方开发人员更希望在两者之间取**折衷**，即进行一定的但不完全的增量定义，如定义点号“.”作为`%message`的结束标志等。

但我个人认为，用户易用性更为重要，即我希望用户在使用我的`Process`接口时直接拷贝python中日志实现时的格式字符串就可以使用。

但为了保证解析速度，我当前的实现对这一格式字符串做了一定的要求，要求占位符之间不能相连，即不能出现`%(created)s%(message)s`这样的情况。

## v0版本实现（当前版本）

（建议结合设计文档查看）

#### 当前实现

基本实现了解析功能

`Process`函数首先调用`preProcess`函数，将格式字符串处理为**分隔串**和**占位符串**组成的序列，返回`FormatSubString`类实例组成的`vector`（注意：要求格式字符串中占位符之间必须有分隔符，不能出现占位符相连的情况）

之后，`Process`函数多次对`InputStr`调用`processSingle`函数，逐条处理输入的日志字符串。

`processSingle`顺序读取`preProcess`返回的`vector`，对于可以特殊处理的占位符串则直接特殊化处理以加速，否则持续读取直至遇到下一分隔串的开始字符，将读取的内容作为当前占位符串所对应的日志字符串，直至`vector`与日志字符串同时处理完毕，返回

#### 未来迭代

* 实现设计文档中的**回溯**功能，提高解析灵活性

* 实现占位符的**格式化长度**解析，如解析`%(created)10s`类似的占位符
